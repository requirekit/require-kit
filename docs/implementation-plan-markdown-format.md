# Implementation Plan Markdown Format

**Status**: Active (as of TASK-027)
**Format Version**: 1.0
**Replaces**: JSON-only storage

## Overview

Implementation plans are now stored as **human-readable Markdown files** with YAML frontmatter metadata. This provides better developer experience, clearer git diffs, and aligns with proven workflow patterns (John Hubbard's .md files).

## Format Specification

### File Location

```
docs/state/{TASK-ID}/implementation_plan.md
```

Example: `docs/state/TASK-042/implementation_plan.md`

### Structure

Implementation plans consist of two parts:

1. **Frontmatter** (YAML) - Structured metadata for programmatic access
2. **Body** (Markdown) - Human-readable plan content

### Frontmatter Schema

```yaml
---
task_id: TASK-XXX              # Required: Task identifier
saved_at: '2025-10-18T...'     # Required: ISO timestamp
version: 1                      # Required: Format version
complexity_score: 5             # Optional: Complexity (0-10)
architectural_review_score: 85  # Optional: Review score (0-100)
status: draft                   # Optional: Plan status
---
```

### Markdown Sections

#### Required Sections

1. **Title** - `# Implementation Plan: {TASK-ID}`
2. **Metadata Header** - Created date, status, complexity
3. **Summary** - Brief description of what will be implemented
4. **Files to Create** - List of new files with descriptions
5. **Estimated Effort** - Duration, LOC, complexity

#### Optional Sections

6. **Files to Modify** - Existing files that will be changed
7. **Dependencies** - External packages/libraries needed
8. **Risks & Mitigation** - Potential issues and solutions
9. **Architectural Review** - SOLID compliance and warnings
10. **Implementation Notes** - Step-by-step guidance
11. **Implementation Phases** - Breakdown of phases
12. **Test Summary** - Testing approach

## Complete Example

```markdown
---
task_id: TASK-042
saved_at: '2025-10-18T14:30:00Z'
version: 1
complexity_score: 5
architectural_review_score: 85
status: approved
---

# Implementation Plan: TASK-042

**Created**: 2025-10-18 14:30:00
**Status**: Approved
**Complexity**: 5/10

## Summary

Implement user authentication system with JWT token management and session handling.

## Files to Create

- `src/auth/AuthService.ts` - Main authentication service
- `src/auth/TokenManager.ts` - JWT token creation/validation
- `tests/unit/AuthService.test.ts` - Unit tests for AuthService
- `tests/unit/TokenManager.test.ts` - Unit tests for TokenManager

## Files to Modify

- `src/app.ts` - Add authentication middleware
- `src/routes/index.ts` - Add auth routes

## Dependencies

- `jsonwebtoken ^9.0.0` - JWT token handling
- `bcrypt ^5.1.0` - Password hashing

## Estimated Effort

- **Duration**: 4 hours
- **Lines of Code**: 245
- **Complexity**: 5/10 (Medium)

## Risks & Mitigation

- **Risk**: JWT secret management
  - **Mitigation**: Use environment variables, never commit secrets

- **Risk**: Token expiration handling
  - **Mitigation**: Implement refresh token mechanism

## Architectural Review

**Score**: 85/100

### SOLID Compliance

✅ **Single Responsibility**: Each class has one clear purpose
✅ **Open/Closed**: Using interfaces for extensibility
✅ **Dependency Inversion**: AuthService depends on ITokenManager interface

### Warnings

⚠️ Consider extracting validation logic into separate class
⚠️ Token storage in localStorage (consider httpOnly cookies for production)

## Implementation Notes

1. Start with TokenManager (dependency)
2. Implement AuthService using TokenManager
3. Write tests for happy path first
4. Add error handling tests
5. Integration test with mock token validation

---
*Generated by AI-Engineer on 2025-10-18T14:30:00Z*
```

## Benefits vs JSON

### Human Readability

**Before (JSON)**:
```json
{
  "plan": {
    "files_to_create": [
      "src/auth.py",
      "tests/test_auth.py"
    ],
    "estimated_loc": 245
  }
}
```

**After (Markdown)**:
```markdown
## Files to Create
- `src/auth.py`
- `tests/test_auth.py`

## Estimated Effort
- **Lines of Code**: 245
```

### Git Diffs

**Before (JSON diff - noisy)**:
```diff
  "plan": {
-   "estimated_loc": 245,
+   "estimated_loc": 380,
    "risks": [
      {
+       "severity": "high"
      }
    ]
  }
```

**After (Markdown diff - clear)**:
```diff
  ## Estimated Effort
- - **Lines of Code**: 245
+ - **Lines of Code**: 380

  ## Risks & Mitigation
  - **Risk**: JWT secret management
+   - **Severity**: High
```

### Manual Editing

Markdown can be safely edited by hand:

```markdown
## Files to Create
- `src/auth/AuthService.ts`
- `src/auth/TokenManager.ts`
+ - `src/auth/SessionStore.ts`  # Human added this
```

JSON editing risks syntax errors:
```json
{
  "files": [
    "file1.py",
    "file2.py"  # Forgot comma - breaks everything!
    "file3.py"
  ]
}
```

## Programmatic Access

### Saving Plans

```python
from installer.global.commands.lib.plan_persistence import save_plan

plan = {
    "summary": "Implement feature X",
    "files_to_create": ["src/feature.py"],
    "estimated_duration": "2 hours"
}

# Saves as markdown with frontmatter
plan_path = save_plan("TASK-042", plan)
# Returns: docs/state/TASK-042/implementation_plan.md
```

### Loading Plans

```python
from installer.global.commands.lib.plan_persistence import load_plan

# Loads markdown (or falls back to legacy JSON)
plan = load_plan("TASK-042")

print(plan["task_id"])  # TASK-042
print(plan["plan"]["summary"])  # Implement feature X
```

### Parsing Markdown Directly

```python
from pathlib import Path
from installer.global.commands.lib.plan_markdown_parser import PlanMarkdownParser

parser = PlanMarkdownParser()
plan = parser.parse_file(Path("docs/state/TASK-042/implementation_plan.md"))

# Access frontmatter
print(plan["version"])  # 1
print(plan["complexity_score"])  # 5

# Access plan data
print(plan["plan"]["files_to_create"])  # ["src/feature.py", ...]
```

### Rendering Plans

```python
from installer.global.commands.lib.plan_markdown_renderer import PlanMarkdownRenderer

renderer = PlanMarkdownRenderer()

plan_data = {
    "task_id": "TASK-042",
    "plan": {"summary": "Feature X"}
}

# Render to markdown string
markdown = renderer.render(plan_data)

# Or save directly
renderer.save_markdown(plan_data, Path("output.md"))
```

## Backward Compatibility

### Legacy JSON Support

The system automatically detects and loads legacy JSON plans:

```python
# Tries markdown first, falls back to JSON
plan = load_plan("TASK-OLD")  # Works with old JSON plans
```

**Migration path**:
1. Old plans continue to work (JSON loaded as fallback)
2. New plans save as markdown only
3. Editing old plan auto-migrates to markdown
4. No breaking changes

### File Priority

When loading plans:
1. Check for `implementation_plan.md` (primary)
2. If missing, check for `implementation_plan.json` (legacy)
3. If both exist, prefer markdown

## Workflow Integration

### Phase 2.7: Implementation Planning

```python
# Generate plan (returns dict)
implementation_plan = generate_implementation_plan(task)

# Architectural review
review_result = review_architecture(implementation_plan)

# Save as markdown (Phase 2.7)
plan_path = save_plan(task_id, implementation_plan, review_result)
print(f"Plan saved to: {plan_path}")
# Output: docs/state/TASK-042/implementation_plan.md
```

### Phase 2.6: Human Checkpoint

```python
# Load plan for human review
plan = load_plan(task_id)

# Human can:
# 1. Read markdown directly (cat docs/state/TASK-042/implementation_plan.md)
# 2. Edit markdown in their editor
# 3. Review in PR/diff tool

# System reloads (with any manual edits)
updated_plan = load_plan(task_id)
```

### Phase 3: Implementation

```python
# Load approved plan
plan = load_plan(task_id)

# Access plan details
for file_path in plan["plan"]["files_to_create"]:
    create_file(file_path)
```

## Best Practices

### For Developers

1. **Review plans in PR** - Markdown is readable, review implementation plans
2. **Edit plans manually** - Safe to edit .md files, no syntax errors
3. **Use git diff** - Clear line-by-line changes in plan diffs
4. **Single source of truth** - Only markdown exists (no .md + .json)

### For AI Agents

1. **Always use save_plan()** - Handles markdown rendering automatically
2. **Load with load_plan()** - Supports both formats seamlessly
3. **Include all fields** - Template handles missing fields gracefully
4. **Structured data** - Use frontmatter for metadata, markdown for content

### For Templates

When creating custom templates:

```jinja2
## Your Custom Section

{% if custom_field %}
- **Custom**: {{ custom_field }}
{% else %}
*Not specified*
{% endif %}
```

## Validation

Plans are validated when:
1. Rendering (template errors caught)
2. Parsing (frontmatter/markdown errors caught)
3. Loading (file not found, corrupted content)

All errors raise `PlanPersistenceError` with clear messages.

## Migration Guide

### From JSON-Only Projects

No action required! The system automatically:
- Saves new plans as markdown
- Loads old JSON plans as fallback
- Preserves all functionality

### Explicit Migration (Optional)

To convert existing JSON plans to markdown:

```python
from pathlib import Path
from plan_persistence import load_plan, save_plan

# Find all JSON plans
json_plans = Path("docs/state").glob("*/implementation_plan.json")

for json_file in json_plans:
    task_id = json_file.parent.name

    # Load JSON
    plan = load_plan(task_id)

    # Save as markdown (preserves data)
    save_plan(task_id, plan["plan"], plan.get("architectural_review"))

    # Optional: Delete JSON after verification
    # json_file.unlink()
```

## Troubleshooting

### Plan Won't Load

```python
from plan_persistence import load_plan

plan = load_plan("TASK-042")
if plan is None:
    print("No plan found - check file exists")
```

### Markdown Parsing Errors

```python
try:
    plan = load_plan("TASK-042")
except PlanPersistenceError as e:
    print(f"Parsing failed: {e}")
    # Check markdown syntax, frontmatter format
```

### Template Errors

```python
try:
    save_plan("TASK-042", plan_data)
except PlanMarkdownRendererError as e:
    print(f"Rendering failed: {e}")
    # Check plan_data structure matches template
```

## References

- Task: TASK-027
- Research: `docs/research/implementation-plan-and-code-review-analysis.md`
- Template: `installer/global/commands/lib/templates/implementation_plan.md.j2`
- Renderer: `installer/global/commands/lib/plan_markdown_renderer.py`
- Parser: `installer/global/commands/lib/plan_markdown_parser.py`
- Tests: `installer/global/commands/lib/test_plan_markdown.py`

## Version History

- **v1.0** (2025-10-18): Initial markdown format
  - YAML frontmatter metadata
  - Human-readable markdown body
  - Backward compatible with JSON
  - Template-based rendering
