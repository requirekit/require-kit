using ErrorOr;
using {{ProjectName}}.Services.Interfaces;

namespace {{ProjectName}}.Domain.{{FeatureName}};

/// <summary>
/// Query operation: {{OperationName}}
/// Returns data without modifying system state.
/// </summary>
public class {{OperationName}}
{
    private readonly I{{Entity}}Repository _repository;
    private readonly ILogService _logService;

    public {{OperationName}}(
        I{{Entity}}Repository repository,
        ILogService logService)
    {
        _repository = repository;
        _logService = logService;
    }

    /// <summary>
    /// Executes the query operation.
    /// </summary>
    /// <returns>Success with {{ReturnType}}, or Error if operation fails</returns>
    public async Task<ErrorOr<{{ReturnType}}>> ExecuteAsync({{Parameters}})
    {
        _logService.TrackEvent("{{OperationName}}Started");

        try
        {
            // Query data from repository
            var result = await _repository.{{RepositoryMethod}}Async({{RepositoryParameters}});

            if (result.IsError)
            {
                _logService.TrackEvent("{{OperationName}}Failed", new Dictionary<string, object>
                {
                    { "ErrorCode", result.FirstError.Code },
                    { "ErrorDescription", result.FirstError.Description }
                });
            }
            else
            {
                _logService.TrackEvent("{{OperationName}}Completed");
            }

            // Return result (success or error)
            return result;
        }
        catch (Exception ex)
        {
            _logService.TrackError(ex, new Dictionary<string, object>
            {
                { "Operation", nameof({{OperationName}}) }
            });

            return Error.Failure(
                code: "{{OperationName}}.UnexpectedError",
                description: "An unexpected error occurred");
        }
    }
}
