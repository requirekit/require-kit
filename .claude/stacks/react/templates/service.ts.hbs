/**
 * {{ServiceName}} Service
 * 
 * @description {{Description}}
 */

import { z } from 'zod';

// Configuration
const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3000';
const DEFAULT_TIMEOUT = 30000; // 30 seconds
const MAX_RETRIES = 3;
const RETRY_DELAY = 1000; // 1 second

// Type definitions
export interface {{ServiceName}}Config {
  baseURL?: string;
  timeout?: number;
  headers?: Record<string, string>;
  maxRetries?: number;
  retryDelay?: number;
}

export interface ApiError {
  code: string;
  message: string;
  details?: unknown;
  timestamp: string;
  statusCode?: number;
}

// Validation schemas (using Zod for runtime validation)
{{#if hasValidation}}
const {{camelCase ServiceName}}Schema = z.object({
  id: z.string(),
  // Add your schema fields here
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
});

export type {{ServiceName}}Data = z.infer<typeof {{camelCase ServiceName}}Schema>;
{{/if}}

/**
 * {{ServiceName}} Service Class
 * 
 * Handles all API interactions for {{ServiceName}}
 */
export class {{ServiceName}}Service {
  private config: Required<{{ServiceName}}Config>;
  private abortControllers: Map<string, AbortController>;
  
  constructor(config: {{ServiceName}}Config = {}) {
    this.config = {
      baseURL: config.baseURL || API_BASE_URL,
      timeout: config.timeout || DEFAULT_TIMEOUT,
      headers: config.headers || {},
      maxRetries: config.maxRetries || MAX_RETRIES,
      retryDelay: config.retryDelay || RETRY_DELAY,
    };
    
    this.abortControllers = new Map();
  }
  
  /**
   * Make an HTTP request with error handling and retries
   */
  private async request<T>(
    endpoint: string,
    options: RequestInit = {},
    requestId?: string
  ): Promise<T> {
    // Cancel any existing request with the same ID
    if (requestId) {
      this.cancel(requestId);
      const controller = new AbortController();
      this.abortControllers.set(requestId, controller);
      options.signal = controller.signal;
    }
    
    const url = `${this.config.baseURL}${endpoint}`;
    const requestConfig: RequestInit = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...this.config.headers,
        ...options.headers,
      },
    };
    
    // Retry logic
    let lastError: Error | undefined;
    
    for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {
      try {
        // Add timeout
        const timeoutId = setTimeout(() => {
          if (requestId) {
            this.cancel(requestId);
          }
        }, this.config.timeout);
        
        const response = await fetch(url, requestConfig);
        clearTimeout(timeoutId);
        
        // Handle response
        if (!response.ok) {
          const error = await this.handleErrorResponse(response);
          throw error;
        }
        
        // Parse response
        const data = await response.json();
        
        {{#if hasValidation}}
        // Validate response data
        if (endpoint.includes('/{{kebab-case ServiceName}}')) {
          return {{camelCase ServiceName}}Schema.parse(data) as T;
        }
        {{/if}}
        
        return data as T;
        
      } catch (error) {
        lastError = error as Error;
        
        // Don't retry on abort errors
        if (lastError.name === 'AbortError') {
          throw lastError;
        }
        
        // Don't retry on client errors (4xx)
        if (lastError instanceof Error && 'statusCode' in lastError) {
          const apiError = lastError as ApiError;
          if (apiError.statusCode && apiError.statusCode >= 400 && apiError.statusCode < 500) {
            throw lastError;
          }
        }
        
        // Wait before retrying
        if (attempt < this.config.maxRetries) {
          await this.delay(this.config.retryDelay * Math.pow(2, attempt));
        }
      }
    }
    
    throw lastError || new Error('Request failed');
  }
  
  /**
   * Handle error responses from the API
   */
  private async handleErrorResponse(response: Response): Promise<ApiError> {
    const error: ApiError = {
      code: `HTTP_${response.status}`,
      message: response.statusText || 'Request failed',
      statusCode: response.status,
      timestamp: new Date().toISOString(),
    };
    
    try {
      const errorData = await response.json();
      error.details = errorData;
      
      // Extract error message from common API error formats
      if (errorData.message) {
        error.message = errorData.message;
      } else if (errorData.error) {
        error.message = typeof errorData.error === 'string' 
          ? errorData.error 
          : errorData.error.message || error.message;
      }
    } catch {
      // If response is not JSON, use status text
    }
    
    return error;
  }
  
  /**
   * Delay helper for retries
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  /**
   * Cancel a specific request
   */
  cancel(requestId: string): void {
    const controller = this.abortControllers.get(requestId);
    if (controller) {
      controller.abort();
      this.abortControllers.delete(requestId);
    }
  }
  
  /**
   * Cancel all pending requests
   */
  cancelAll(): void {
    this.abortControllers.forEach(controller => controller.abort());
    this.abortControllers.clear();
  }
  
  // API Methods
  
  /**
   * Get all items
   */
  async getAll(params?: Record<string, any>): Promise<{{ServiceName}}Data[]> {
    const queryString = params ? `?${new URLSearchParams(params).toString()}` : '';
    return this.request<{{ServiceName}}Data[]>(
      `/{{kebab-case ServiceName}}${queryString}`,
      { method: 'GET' },
      'getAll'
    );
  }
  
  /**
   * Get a single item by ID
   */
  async getById(id: string): Promise<{{ServiceName}}Data> {
    return this.request<{{ServiceName}}Data>(
      `/{{kebab-case ServiceName}}/${id}`,
      { method: 'GET' },
      `get-${id}`
    );
  }
  
  /**
   * Create a new item
   */
  async create(data: Partial<{{ServiceName}}Data>): Promise<{{ServiceName}}Data> {
    return this.request<{{ServiceName}}Data>(
      `/{{kebab-case ServiceName}}`,
      {
        method: 'POST',
        body: JSON.stringify(data),
      },
      'create'
    );
  }
  
  /**
   * Update an existing item
   */
  async update(id: string, data: Partial<{{ServiceName}}Data>): Promise<{{ServiceName}}Data> {
    return this.request<{{ServiceName}}Data>(
      `/{{kebab-case ServiceName}}/${id}`,
      {
        method: 'PUT',
        body: JSON.stringify(data),
      },
      `update-${id}`
    );
  }
  
  /**
   * Partially update an item
   */
  async patch(id: string, data: Partial<{{ServiceName}}Data>): Promise<{{ServiceName}}Data> {
    return this.request<{{ServiceName}}Data>(
      `/{{kebab-case ServiceName}}/${id}`,
      {
        method: 'PATCH',
        body: JSON.stringify(data),
      },
      `patch-${id}`
    );
  }
  
  /**
   * Delete an item
   */
  async delete(id: string): Promise<void> {
    return this.request<void>(
      `/{{kebab-case ServiceName}}/${id}`,
      { method: 'DELETE' },
      `delete-${id}`
    );
  }
  
  {{#if hasStreaming}}
  /**
   * Stream data using Server-Sent Events
   */
  stream(
    endpoint: string,
    options: {
      onMessage?: (data: any) => void;
      onError?: (error: Error) => void;
      onComplete?: () => void;
    } = {}
  ): () => void {
    const url = `${this.config.baseURL}${endpoint}`;
    const eventSource = new EventSource(url);
    
    eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        options.onMessage?.(data);
      } catch (error) {
        console.error('Failed to parse SSE message:', error);
      }
    };
    
    eventSource.onerror = (error) => {
      console.error('SSE error:', error);
      options.onError?.(new Error('Stream connection failed'));
      eventSource.close();
      options.onComplete?.();
    };
    
    eventSource.addEventListener('complete', () => {
      eventSource.close();
      options.onComplete?.();
    });
    
    // Return cleanup function
    return () => {
      eventSource.close();
    };
  }
  {{/if}}
  
  {{#if hasBatch}}
  /**
   * Batch operations
   */
  async batch(operations: Array<{
    method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
    endpoint: string;
    data?: any;
  }>): Promise<any[]> {
    return this.request<any[]>(
      `/batch`,
      {
        method: 'POST',
        body: JSON.stringify({ operations }),
      },
      'batch'
    );
  }
  {{/if}}
}

// Singleton instance for convenient usage
export const {{camelCase ServiceName}}Service = new {{ServiceName}}Service();

// React hook for using the service
export function use{{ServiceName}}Service(config?: {{ServiceName}}Config) {
  const service = useMemo(() => {
    return new {{ServiceName}}Service(config);
  }, [config]);
  
  useEffect(() => {
    return () => {
      // Cleanup: cancel all pending requests when component unmounts
      service.cancelAll();
    };
  }, [service]);
  
  return service;
}