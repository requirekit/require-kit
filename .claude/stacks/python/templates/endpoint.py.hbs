"""
API endpoint for {{resourceName}}

EARS Requirements:
- REQ-{{upperCase resourceName}}-001: The system shall provide CRUD operations for {{resourceName}}
- REQ-{{upperCase resourceName}}-002: All {{resourceName}} operations shall validate input data
- REQ-{{upperCase resourceName}}-003: The system shall return appropriate error messages

BDD Scenarios:
- BDD-{{upperCase resourceName}}-001: User can create a new {{resourceName}}
- BDD-{{upperCase resourceName}}-002: User can retrieve {{resourceName}} by ID
- BDD-{{upperCase resourceName}}-003: System validates {{resourceName}} data
"""

from typing import List, Optional, Dict, Any
from fastapi import APIRouter, Depends, HTTPException, Query, status, Request
from fastapi.responses import StreamingResponse
from pydantic import BaseModel, Field, validator
from datetime import datetime
import json
import asyncio
import structlog

from src.models.{{snakeCase resourceName}} import (
    {{pascalCase resourceName}}Create,
    {{pascalCase resourceName}}Update,
    {{pascalCase resourceName}}Response,
    {{pascalCase resourceName}}ListResponse
)
from src.services.{{snakeCase resourceName}} import create_{{snakeCase resourceName}}_service
from src.utils.error_handling import with_error_handling, APIError
from src.utils.auth import get_current_user
from src.utils.monitoring import monitor_performance
from src.models.user import User

# Initialize structured logger
logger = structlog.get_logger(__name__)

# Create router with prefix and tags
router = APIRouter(
    prefix="/api/v1/{{kebabCase resourceName}}s",
    tags=["{{resourceName}}s"],
    responses={
        404: {"description": "{{resourceName}} not found"},
        403: {"description": "Not authorized"},
        500: {"description": "Internal server error"}
    }
)


@router.get("/", response_model={{pascalCase resourceName}}ListResponse)
@monitor_performance
@with_error_handling(raise_on_error=True)
async def list_{{snakeCase resourceName}}s(
    skip: int = Query(0, ge=0, description="Number of items to skip"),
    limit: int = Query(100, ge=1, le=100, description="Number of items to return"),
    search: Optional[str] = Query(None, description="Search term"),
    sort_by: Optional[str] = Query(None, description="Field to sort by"),
    current_user: User = Depends(get_current_user)
) -> {{pascalCase resourceName}}ListResponse:
    """
    List {{resourceName}}s with pagination, search, and sorting.
    
    - **skip**: Number of records to skip for pagination
    - **limit**: Maximum number of records to return (max 100)
    - **search**: Optional search term to filter results
    - **sort_by**: Field name to sort results by
    
    Returns:
        {{pascalCase resourceName}}ListResponse with items and metadata
    """
    logger.info(
        "listing_{{snakeCase resourceName}}s",
        user_id=current_user.id,
        skip=skip,
        limit=limit,
        search=search
    )
    
    # Use factory to create service
    service = create_{{snakeCase resourceName}}_service()
    
    # Get items with pagination
    items = await service.list(
        skip=skip,
        limit=limit,
        search=search,
        sort_by=sort_by,
        user=current_user
    )
    
    # Get total count for pagination metadata
    total = await service.count(search=search, user=current_user)
    
    logger.info(
        "listed_{{snakeCase resourceName}}s",
        user_id=current_user.id,
        count=len(items),
        total=total
    )
    
    return {{pascalCase resourceName}}ListResponse(
        items=items,
        total=total,
        skip=skip,
        limit=limit,
        metadata={
            "has_more": (skip + limit) < total,
            "page": (skip // limit) + 1 if limit > 0 else 1
        }
    )


@router.get("/{id}", response_model={{pascalCase resourceName}}Response)
@monitor_performance
@with_error_handling(raise_on_error=True)
async def get_{{snakeCase resourceName}}(
    id: str,
    current_user: User = Depends(get_current_user)
) -> {{pascalCase resourceName}}Response:
    """
    Get a specific {{resourceName}} by ID.
    
    Args:
        id: Unique identifier of the {{resourceName}}
        
    Returns:
        {{pascalCase resourceName}}Response with full details
        
    Raises:
        HTTPException: 404 if {{resourceName}} not found
    """
    logger.info(
        "getting_{{snakeCase resourceName}}",
        user_id=current_user.id,
        {{snakeCase resourceName}}_id=id
    )
    
    service = create_{{snakeCase resourceName}}_service()
    item = await service.get(id=id, user=current_user)
    
    if not item:
        logger.warning(
            "{{snakeCase resourceName}}_not_found",
            user_id=current_user.id,
            {{snakeCase resourceName}}_id=id
        )
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"{{resourceName}} with id '{id}' not found"
        )
    
    return item


@router.post("/", response_model={{pascalCase resourceName}}Response, status_code=status.HTTP_201_CREATED)
@monitor_performance
@with_error_handling(raise_on_error=True)
async def create_{{snakeCase resourceName}}(
    data: {{pascalCase resourceName}}Create,
    current_user: User = Depends(get_current_user)
) -> {{pascalCase resourceName}}Response:
    """
    Create a new {{resourceName}}.
    
    Args:
        data: {{resourceName}} creation data
        
    Returns:
        {{pascalCase resourceName}}Response with created item
        
    Raises:
        HTTPException: 400 if validation fails
        HTTPException: 409 if {{resourceName}} already exists
    """
    logger.info(
        "creating_{{snakeCase resourceName}}",
        user_id=current_user.id,
        data=data.dict()
    )
    
    try:
        service = create_{{snakeCase resourceName}}_service()
        item = await service.create(data=data, user=current_user)
        
        logger.info(
            "created_{{snakeCase resourceName}}",
            user_id=current_user.id,
            {{snakeCase resourceName}}_id=item.id
        )
        
        return item
        
    except ValueError as e:
        logger.error(
            "{{snakeCase resourceName}}_creation_failed",
            user_id=current_user.id,
            error=str(e)
        )
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except APIError as e:
        if "already exists" in str(e).lower():
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail=str(e)
            )
        raise


@router.put("/{id}", response_model={{pascalCase resourceName}}Response)
@monitor_performance
@with_error_handling(raise_on_error=True)
async def update_{{snakeCase resourceName}}(
    id: str,
    data: {{pascalCase resourceName}}Update,
    current_user: User = Depends(get_current_user)
) -> {{pascalCase resourceName}}Response:
    """
    Update an existing {{resourceName}}.
    
    Args:
        id: Unique identifier of the {{resourceName}}
        data: Update data (partial updates supported)
        
    Returns:
        {{pascalCase resourceName}}Response with updated item
        
    Raises:
        HTTPException: 404 if {{resourceName}} not found
        HTTPException: 400 if validation fails
    """
    logger.info(
        "updating_{{snakeCase resourceName}}",
        user_id=current_user.id,
        {{snakeCase resourceName}}_id=id,
        updates=data.dict(exclude_unset=True)
    )
    
    service = create_{{snakeCase resourceName}}_service()
    
    # Support partial updates - only update provided fields
    item = await service.update(
        id=id,
        data=data,
        user=current_user,
        partial=True
    )
    
    if not item:
        logger.warning(
            "{{snakeCase resourceName}}_not_found_for_update",
            user_id=current_user.id,
            {{snakeCase resourceName}}_id=id
        )
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"{{resourceName}} with id '{id}' not found"
        )
    
    logger.info(
        "updated_{{snakeCase resourceName}}",
        user_id=current_user.id,
        {{snakeCase resourceName}}_id=id
    )
    
    return item


@router.delete("/{id}", status_code=status.HTTP_204_NO_CONTENT)
@monitor_performance
@with_error_handling(raise_on_error=True)
async def delete_{{snakeCase resourceName}}(
    id: str,
    current_user: User = Depends(get_current_user)
) -> None:
    """
    Delete a {{resourceName}}.
    
    Args:
        id: Unique identifier of the {{resourceName}}
        
    Raises:
        HTTPException: 404 if {{resourceName}} not found
        HTTPException: 403 if not authorized to delete
    """
    logger.info(
        "deleting_{{snakeCase resourceName}}",
        user_id=current_user.id,
        {{snakeCase resourceName}}_id=id
    )
    
    service = create_{{snakeCase resourceName}}_service()
    success = await service.delete(id=id, user=current_user)
    
    if not success:
        logger.warning(
            "{{snakeCase resourceName}}_not_found_for_deletion",
            user_id=current_user.id,
            {{snakeCase resourceName}}_id=id
        )
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"{{resourceName}} with id '{id}' not found"
        )
    
    logger.info(
        "deleted_{{snakeCase resourceName}}",
        user_id=current_user.id,
        {{snakeCase resourceName}}_id=id
    )


# Optional: Add streaming endpoint for AI-powered features
@router.post("/{id}/process/stream")
async def stream_{{snakeCase resourceName}}_processing(
    id: str,
    request: Dict[str, Any],
    current_user: User = Depends(get_current_user)
):
    """
    Stream processing results for {{resourceName}} using Server-Sent Events.
    
    This endpoint is useful for AI-powered features that need real-time streaming.
    
    Args:
        id: Unique identifier of the {{resourceName}}
        request: Processing parameters
        
    Returns:
        StreamingResponse with SSE events
    """
    logger.info(
        "streaming_{{snakeCase resourceName}}_processing",
        user_id=current_user.id,
        {{snakeCase resourceName}}_id=id
    )
    
    async def generate_stream():
        """Generate SSE stream for processing results."""
        try:
            service = create_{{snakeCase resourceName}}_service()
            
            # Get the {{resourceName}} to process
            item = await service.get(id=id, user=current_user)
            if not item:
                yield f"data: {json.dumps({'event': 'error', 'data': '{{resourceName}} not found'})}\n\n"
                return
            
            # Process with streaming (if your service supports it)
            async for chunk in service.process_streaming(item, request):
                data = {
                    "event": "message",
                    "data": json.dumps({"content": chunk})
                }
                yield f"data: {json.dumps(data)}\n\n"
                await asyncio.sleep(0.01)  # Small delay to prevent overwhelming client
            
            # Send completion event
            yield f"data: {json.dumps({'event': 'done'})}\n\n"
            
        except Exception as e:
            logger.error(
                "streaming_error",
                user_id=current_user.id,
                {{snakeCase resourceName}}_id=id,
                error=str(e)
            )
            error_data = {
                "event": "error",
                "data": json.dumps({"error": str(e)})
            }
            yield f"data: {json.dumps(error_data)}\n\n"
    
    return StreamingResponse(
        generate_stream(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",  # Disable nginx buffering
            "Connection": "keep-alive",
        }
    )


# Optional: Batch operations endpoint
@router.post("/batch", response_model=List[{{pascalCase resourceName}}Response])
@monitor_performance
@with_error_handling(raise_on_error=True)
async def batch_create_{{snakeCase resourceName}}s(
    items: List[{{pascalCase resourceName}}Create],
    current_user: User = Depends(get_current_user)
) -> List[{{pascalCase resourceName}}Response]:
    """
    Create multiple {{resourceName}}s in a single request.
    
    Args:
        items: List of {{resourceName}}s to create (max 100)
        
    Returns:
        List of created {{resourceName}}s
        
    Raises:
        HTTPException: 400 if validation fails or too many items
    """
    if len(items) > 100:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Maximum 100 items allowed in batch operation"
        )
    
    logger.info(
        "batch_creating_{{snakeCase resourceName}}s",
        user_id=current_user.id,
        count=len(items)
    )
    
    service = create_{{snakeCase resourceName}}_service()
    created_items = await service.batch_create(items=items, user=current_user)
    
    logger.info(
        "batch_created_{{snakeCase resourceName}}s",
        user_id=current_user.id,
        created_count=len(created_items)
    )
    
    return created_items
